package thread.happensBefore;

/**
 * Created by webserg on 02.05.2014.
 * Синхронизация гарантирует, что данные записанные в память до или в синхронизированном блоке становятся предсказуемо видимыми
 * для других потоков, которые синхронизируются на том же мониторе. . После того как мы выходим из синхронизированного блока, мы
 * освобождаем (release) монитор, что имеет эффект сбрасывания (flush) кэша в оперативную память, так что запись сделанные
 * нашим потоком могут быть видимыми для других потоков. Прежде чем мы сможем войти в синхронизированный блок, мы захватываем
 * (asquire) монитор, что имеет эффект объявления недействительными данных локального процессорного кэша (invalidating the local
 * processor cache), так что переменные будут загружены из основной памяти. Тогда мы сможем увидеть все записи, сделанные видимым
 * предыдущим освобождением (release) монитора.
 * <p>
 * Каждое действие в потоке «происходит прежде» (happens before) любого другого действия в этом потоке, которое идет «ниже» в коде этого потока.
 * Освобождение монитора «происходит прежде» (happens before) каждого последующего захвата того же самого монитора.
 * Запись в volatile-поле происходит «происходит прежде» (happens before) каждого последующего чтения того же самого volatile-поля.
 * Вызов метода start() потока «происходит прежде» (happens before) любых действий в запущенном потоке.
 * Все действия в потоке «происходят прежде» (happens before) любых действий любого другого потока, который успешно завершил
 * ожидание на join() по первому потоку.
 */
public class UsingVolatile {
    /*
     * Эта программа (data — volatile, run — volatile) гарантированно остановится и напечатает 1 И в старой И в новой моделях памяти
     * */
    static volatile int data = 0;
    static volatile boolean run = true;

    public static void main(String[] args) {
        new Thread(new Runnable() {
            public void run() {
                data = 1;
                run = false;
            }
        }).start();

        while (run) {/*NOP*/}
        ;
        System.out.println(data);
    }

}
